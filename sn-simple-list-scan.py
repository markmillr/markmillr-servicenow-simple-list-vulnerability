import requests
import pandas as pd
import numpy as np
import re
import json
import argparse
from datetime import datetime, timedelta
import os
import time

def format_time_delta(td):
    total_seconds = int(td.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours}h {minutes}m {seconds}s"

def main(instance_name, file_name, verbosity, generate_files):
    url = f"https://{instance_name}.service-now.com/login.do"
    
    payload = {}
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }

    try:
        print(f"Visiting {url} as non-logged in user to retrieve token and cookies for table scan")
        response1 = requests.get(url, headers=headers, data=payload)
        response1.raise_for_status()
        cookie = response1.cookies
        html_content = response1.content.decode('utf-8')
    except requests.RequestException as e:
        print(f"Error while making request: {e}")
        return

    pattern = r"var\s+g_ck\s*=\s*'([^']+)';"
    match = re.search(pattern, html_content)

    if match:
        g_ck_value = match.group(1).replace(" ",'')
        print(f"g_ck value: {g_ck_value}")

        formatted_cookies = "; ".join([f"{key}={value}" for key, value in response1.cookies.items()])
        print(f"Cookies for Postman: {formatted_cookies}")
    else:
        print("g_ck not found in the HTML")
        return

    start_time = datetime.utcnow()

    output_dir = "output"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    directory_name = f"{output_dir}/scan_results_{instance_name}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
    os.makedirs(directory_name)
    
    if g_ck_value:
        api_url = f"https://{instance_name}.service-now.com/api/now/sp/widget/widget-simple-list"
        try:
            with open(file_name, 'r') as file:
                tables = file.read().splitlines()
        except IOError as e:
            print(f"Error reading file: {e}")
            return

        total_tables = len(tables)
        print(f"Total number of tables to scan: {total_tables}")

        df = pd.DataFrame({
            'name': tables,
            'result': np.full(len(tables), False, dtype=bool),
            'processed': np.full(len(tables), False, dtype=bool),
            'dataRetrieved': np.full(len(tables), None, dtype=object),
            'isValid': np.full(len(tables), np.nan, dtype=object),
            'public': np.full(len(tables), np.nan, dtype=object),
            'count': [0] * len(tables),
            'listCount': [0] * len(tables),
            'data': [None] * len(tables)
        })

        publicly_accessible_tables = 0
        for index, row in df.iterrows():
            time.sleep(0.1)  # To prevent rate limiting

            current_time = datetime.utcnow()
            elapsed_time = current_time - start_time
            avg_time_per_table = elapsed_time / (index + 1)
            estimated_remaining = avg_time_per_table * (total_tables - index - 1)

            table_name = row['name']
            
            headers = {
                'X-UserToken': g_ck_value,
                'Content-Type': 'application/json',
                'Accept': 'application/json',              
            }
            url = api_url + f"?t={table_name}"
            print(f"\nChecking table {table_name} ({index + 1}/{total_tables}) at {url}")
            try:
                response = requests.post(url, headers=headers, cookies=cookie)
                response.raise_for_status()
                result = response.json()['result']
                data = result['data']
                if 'list' in data:
                    if verbosity == "full":
                        print(f"Full response:\n\n{json.dumps(result, indent=4)}")
                    elif verbosity == "data_only":
                        print(f"Response.data:\n\n{json.dumps(data, indent=4)}")
                    elif verbosity == "list_only":
                        print(f"Records:\n\n{json.dumps(data['list'], indent=4)}")

                    if data['list']:
                        publicly_accessible_tables += 1
                        print(f"\033[91m❌ Returns publicly accessible data\033[0m")
                    else:
                        print(f"\033[92m✔ No data returned\033[0m")
                else:
                    print(f"\033[92m✔ No data returned\033[0m")

                is_valid = data['isValid']
                is_public = result['public']
                count = data.get('count', 0)
                list_count = len(data.get('list', []))
                df.at[index, 'isValid'] = is_valid
                df.at[index, 'public'] = is_public
                df.at[index, 'count'] = count
                df.at[index, 'listCount'] = list_count
                
                print(f"Table {table_name}: 'isValid': {is_valid}, 'public': {is_public}, 'count': {count}, 'listCount': {list_count}")
            except requests.RequestException as e:
                print(f"Error while making request for table {table_name}: {e}")
                continue

            df.at[index, 'isValid'] = is_valid

            data_count = len(data.get('list', []))
            data_retrieved = data_count > 0
            df.at[index, 'dataRetrieved'] = data_retrieved
            if data_retrieved:
                df.at[index, 'data'] = data['list'][0]

            df.at[index, 'count'] = data.get('count', 0)
            df.at[index, 'listCount'] = data_count
            if list_count > 0:
                print(f"Data returned for table {table_name}")
                df.at[index, 'result'] = True
                try:
                    with open(f"{table_name}.json", 'w') as json_file:
                        json.dump(data, json_file)
                except IOError as e:
                    print(f"Error saving JSON for table {table_name}: {e}")
            else:
                df.at[index, 'result'] = False

            df.at[index, 'processed'] = True
            print(f"Estimated time remaining: {estimated_remaining}")

        df['dataRetrieved'] = df['dataRetrieved'].fillna(False).astype(bool)
        df['isValid'] = df['isValid'].fillna(False).astype(bool)
        df['public'] = df['public'].fillna(False).astype(bool)

        output_file_name = None
        publicly_accessible_file_name = None

        if generate_files:
            zulu_time = datetime.utcnow().strftime('%Y-%m-%d_T%H-%M-%S_Z')
            output_file_name = f"{directory_name}/simple-list-widget-vulnerability-scan_{instance_name}_{zulu_time}.csv"
            try:
                df.to_csv(output_file_name, index=False)
            except IOError as e:
                print(f"Error saving CSV: {e}")

            publicly_accessible_df = df[(df['isValid'] == True) | (df['dataRetrieved'] == True)]
            publicly_accessible_file_name = f"{directory_name}/publicly_available_simple-list-widget-vulnerability-scan_{instance_name}_{zulu_time}.csv"
            try:
                publicly_accessible_df.to_csv(publicly_accessible_file_name, index=False)
            except IOError as e:
                print(f"Error saving publicly accessible CSV: {e}")

        elapsed_time_formatted = format_time_delta(datetime.utcnow() - start_time)
    
        leaking_tables = df[df['dataRetrieved'] == True]['name'].tolist()

    if generate_files and output_file_name and publicly_accessible_file_name:
        print(f"\nResults saved in: {output_file_name}")
        print(f"Publicly accessible tables saved in: {publicly_accessible_file_name}")
    else:
        print("\nResults are not saved to files.")
        
    print(f"\nScan completed in {elapsed_time_formatted}")
    if publicly_accessible_tables > 0:
        print(f"\033[91m❌\033[0m Total publicly accessible tables: {publicly_accessible_tables}/{total_tables}")
    else:
        print(f"\033[92m✔\033[0m No tables leaked data.")
    if leaking_tables:
        print("Tables leaking data:")
        for table in leaking_tables:
            print(f"- {table}")
    print(f"\nResults saved in: {output_file_name}")
    print(f"Publicly accessible tables saved in: {publicly_accessible_file_name}")



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Scan ServiceNow instance for simple list widget vulnerability.")
    parser.add_argument('instance_name', type=str, help="ServiceNow instance name. For example: 'dev12345'")
    parser.add_argument('file_name', type=str, help="Filename containing list of tables to scan.")
    parser.add_argument('--generate-files', action='store_true', help="Generate output files for the scan results.")
    parser.add_argument('-v', '--verbosity', choices=['full', 'data_only', 'list_only', 'none'], default='none', help="Adjust verbosity level of the output.")
    
    args = parser.parse_args()
    main(args.instance_name, args.file_name, args.verbosity, args.generate_files)

